# Commandes et Fonctions ISE - TP3 et TP4

Guide complet de toutes les fonctions syst√®me utilis√©es dans les TPs 3 et 4

---

## üìÅ TP3 - FLUX (STREAMS)

### üîß Flux Noyau (Kernel Streams)

Les flux noyau sont des appels syst√®me directs. Pas de buffering automatique.

---

#### `open()` - Ouvrir un fichier

**Prototype :**
```c
#include <fcntl.h>
int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
```

**Description :**  
Ouvre un fichier et retourne un **descripteur de fichier (fd)**.

**Param√®tres :**
- `pathname` : Chemin du fichier
- `flags` : Mode d'ouverture (combinables avec `|`)
  - `O_RDONLY` : Lecture seule
  - `O_WRONLY` : √âcriture seule
  - `O_RDWR` : Lecture ET √©criture
  - `O_CREAT` : Cr√©er si n'existe pas (n√©cessite `mode`)
  - `O_TRUNC` : Vider le fichier s'il existe
  - `O_APPEND` : √âcrire √† la fin
  - `O_EXCL` : √âchoue si fichier existe (avec `O_CREAT`)
- `mode` : Permissions (si cr√©ation) - ex: `0644` = rw-r--r--

**Retour :**
- **Succ√®s** : Num√©ro du fd (‚â• 0)
- **Erreur** : `-1` (et `errno` est d√©fini)

**Exemples :**
```c
// Ouvrir en lecture seule
int fd = open("fichier.txt", O_RDONLY);
if (fd < 0) {
    perror("open");
    return 1;
}

// Cr√©er un fichier en √©criture (permissions 644)
int fd = open("nouveau.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

// Ouvrir en lecture/√©criture, cr√©er si besoin
int fd = open("data.bin", O_RDWR | O_CREAT, 0666);

// Ajouter √† la fin d'un fichier existant
int fd = open("log.txt", O_WRONLY | O_APPEND);
```

**Erreurs courantes :**
- `ENOENT` : Fichier n'existe pas (sans `O_CREAT`)
- `EACCES` : Permission refus√©e
- `EISDIR` : C'est un r√©pertoire
- `EMFILE` : Trop de fichiers ouverts

---

#### `close()` - Fermer un descripteur

**Prototype :**
```c
#include <unistd.h>
int close(int fd);
```

**Description :**  
Ferme un descripteur de fichier. **TOUJOURS fermer apr√®s usage !**

**Param√®tres :**
- `fd` : Descripteur √† fermer

**Retour :**
- **Succ√®s** : `0`
- **Erreur** : `-1`

**Exemples :**
```c
int fd = open("fichier.txt", O_RDONLY);
// ... utilisation ...
close(fd);  // OBLIGATOIRE

// V√©rifier l'erreur (rare mais possible)
if (close(fd) < 0) {
    perror("close");
}
```

**Pourquoi fermer ?**
- Lib√®re les ressources syst√®me
- Limite du nombre de fd ouverts par processus (typiquement 1024)
- Garantit l'√©criture des donn√©es sur disque
- √âvite les fuites de ressources

---

#### `read()` - Lire des donn√©es

**Prototype :**
```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t count);
```

**Description :**  
Lit jusqu'√† `count` octets depuis le fd dans le buffer.

**Param√®tres :**
- `fd` : Descripteur de fichier
- `buf` : Buffer o√π stocker les donn√©es lues
- `count` : Nombre MAX d'octets √† lire

**Retour :**
- **Succ√®s** : Nombre d'octets lus (peut √™tre < count)
- **Fin de fichier** : `0`
- **Erreur** : `-1`

**Exemples :**
```c
char buffer[100];

// Lire jusqu'√† 100 octets
ssize_t n = read(fd, buffer, 100);
if (n < 0) {
    perror("read");
    return 1;
}
if (n == 0) {
    printf("Fin de fichier\n");
}
printf("Lu %zd octets\n", n);

// Lire tout un fichier
char data[1000];
ssize_t total = 0;
ssize_t n;
while ((n = read(fd, data + total, sizeof(data) - total)) > 0) {
    total += n;
}
```

**Points importants :**
- `read()` peut lire **moins** que demand√© (pas une erreur)
- Retourne `0` √† la fin du fichier
- Le curseur avance automatiquement
- Pas de `\0` ajout√© (c'est pas une string)

---

#### `write()` - √âcrire des donn√©es

**Prototype :**
```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t count);
```

**Description :**  
√âcrit `count` octets depuis le buffer vers le fd.

**Param√®tres :**
- `fd` : Descripteur de fichier
- `buf` : Buffer contenant les donn√©es √† √©crire
- `count` : Nombre d'octets √† √©crire

**Retour :**
- **Succ√®s** : Nombre d'octets √©crits (peut √™tre < count)
- **Erreur** : `-1`

**Exemples :**
```c
// √âcrire une cha√Æne
const char *msg = "Hello\n";
ssize_t n = write(fd, msg, strlen(msg));
if (n < 0) {
    perror("write");
}

// √âcrire un buffer
char data[100] = {0};
ssize_t written = write(fd, data, 100);

// √âcrire sur stdout (fd = 1)
write(1, "Message\n", 8);

// √âcrire sur stderr (fd = 2)
write(2, "Erreur\n", 7);
```

**Points importants :**
- `write()` peut √©crire **moins** que demand√©
- Toujours v√©rifier le retour
- Pas de `\n` automatique
- Les donn√©es peuvent √™tre bufferis√©es par le syst√®me

---

#### `lseek()` - D√©placer le curseur

**Prototype :**
```c
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```

**Description :**  
D√©place le curseur de lecture/√©criture dans le fichier.

**Param√®tres :**
- `fd` : Descripteur de fichier
- `offset` : D√©placement (en octets)
- `whence` : Point de r√©f√©rence
  - `SEEK_SET` : Depuis le d√©but (position absolue)
  - `SEEK_CUR` : Depuis la position actuelle (relatif)
  - `SEEK_END` : Depuis la fin

**Retour :**
- **Succ√®s** : Nouvelle position (depuis le d√©but)
- **Erreur** : `-1`

**Exemples :**
```c
// Aller au d√©but
lseek(fd, 0, SEEK_SET);

// Aller √† la fin (obtenir la taille)
off_t size = lseek(fd, 0, SEEK_END);
printf("Taille du fichier : %ld octets\n", (long)size);

// Revenir au d√©but apr√®s avoir obtenu la taille
lseek(fd, 0, SEEK_SET);

// Avancer de 10 octets
lseek(fd, 10, SEEK_CUR);

// Reculer de 5 octets
lseek(fd, -5, SEEK_CUR);

// Aller √† l'octet 100
lseek(fd, 100, SEEK_SET);

// Aller 10 octets avant la fin
lseek(fd, -10, SEEK_END);
```

**Astuce : obtenir la taille d'un fichier**
```c
off_t size = lseek(fd, 0, SEEK_END);
lseek(fd, 0, SEEK_SET);  // Revenir au d√©but
```

---

#### `fstat()` - Obtenir infos sur un fichier

**Prototype :**
```c
#include <sys/stat.h>
int fstat(int fd, struct stat *buf);
```

**Description :**  
R√©cup√®re les m√©tadonn√©es d'un fichier ouvert.

**Structure `stat` :**
```c
struct stat {
    dev_t     st_dev;     // ID du p√©riph√©rique
    ino_t     st_ino;     // Num√©ro d'inode
    mode_t    st_mode;    // Permissions et type
    nlink_t   st_nlink;   // Nombre de liens
    uid_t     st_uid;     // User ID propri√©taire
    gid_t     st_gid;     // Group ID propri√©taire
    dev_t     st_rdev;    // ID p√©riph√©rique (si sp√©cial)
    off_t     st_size;    // Taille en octets
    blksize_t st_blksize; // Taille bloc I/O
    blkcnt_t  st_blocks;  // Nombre de blocs 512B
    time_t    st_atime;   // Dernier acc√®s
    time_t    st_mtime;   // Derni√®re modif
    time_t    st_ctime;   // Dernier changement statut
};
```

**Exemples :**
```c
struct stat sb;

if (fstat(fd, &sb) < 0) {
    perror("fstat");
    return 1;
}

// Obtenir la taille
printf("Taille : %ld octets\n", (long)sb.st_size);

// V√©rifier le type
if (S_ISREG(sb.st_mode)) {
    printf("Fichier r√©gulier\n");
} else if (S_ISDIR(sb.st_mode)) {
    printf("R√©pertoire\n");
} else if (S_ISFIFO(sb.st_mode)) {
    printf("FIFO (pipe nomm√©)\n");
}

// V√©rifier les permissions
if (sb.st_mode & S_IRUSR) printf("Lecture propri√©taire\n");
if (sb.st_mode & S_IWUSR) printf("√âcriture propri√©taire\n");
if (sb.st_mode & S_IXUSR) printf("Ex√©cution propri√©taire\n");
```

**Macros utiles :**
- `S_ISREG(mode)` : Fichier r√©gulier ?
- `S_ISDIR(mode)` : R√©pertoire ?
- `S_ISFIFO(mode)` : FIFO ?
- `S_ISLNK(mode)` : Lien symbolique ?

---

### üìö Flux Libc (Standard C Library)

Les flux libc utilisent un buffering automatique pour optimiser les performances.

---

#### `fopen()` - Ouvrir un fichier (libc)

**Prototype :**
```c
#include <stdio.h>
FILE *fopen(const char *pathname, const char *mode);
```

**Description :**  
Ouvre un fichier et retourne un pointeur `FILE*`.

**Modes :**
- `"r"` : Lecture (fichier doit exister)
- `"w"` : √âcriture (cr√©e ou vide)
- `"a"` : Ajout (cr√©e ou √©crit √† la fin)
- `"r+"` : Lecture + √©criture (fichier doit exister)
- `"w+"` : Lecture + √©criture (cr√©e ou vide)
- `"a+"` : Lecture + ajout
- `"rb"`, `"wb"`, etc. : Mode binaire (utile sur Windows)

**Retour :**
- **Succ√®s** : Pointeur `FILE*`
- **Erreur** : `NULL`

**Exemples :**
```c
// Ouvrir en lecture
FILE *f = fopen("fichier.txt", "r");
if (f == NULL) {
    perror("fopen");
    return 1;
}

// Cr√©er en √©criture
FILE *f = fopen("nouveau.txt", "w");

// Ajouter √† la fin
FILE *f = fopen("log.txt", "a");

// Lecture/√©criture
FILE *f = fopen("data.bin", "r+");
```

---

#### `fclose()` - Fermer un FILE*

**Prototype :**
```c
#include <stdio.h>
int fclose(FILE *stream);
```

**Description :**  
Ferme un flux et flush les buffers.

**Exemples :**
```c
FILE *f = fopen("fichier.txt", "r");
// ... utilisation ...
fclose(f);  // OBLIGATOIRE
```

---

#### `fread()` - Lire avec libc

**Prototype :**
```c
#include <stdio.h>
size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);
```

**Description :**  
Lit `nmemb` √©l√©ments de taille `size` depuis le stream.

**Param√®tres :**
- `ptr` : Buffer destination
- `size` : Taille d'un √©l√©ment
- `nmemb` : Nombre d'√©l√©ments
- `stream` : Flux

**Retour :**
- Nombre d'√©l√©ments lus (peut √™tre < nmemb)

**Exemples :**
```c
char buffer[100];

// Lire 100 caract√®res
size_t n = fread(buffer, 1, 100, f);
printf("Lu %zu octets\n", n);

// Lire un tableau d'entiers
int data[10];
size_t count = fread(data, sizeof(int), 10, f);
printf("Lu %zu entiers\n", count);

// V√©rifier la fin de fichier
if (feof(f)) {
    printf("Fin de fichier\n");
}
```

---

#### `fwrite()` - √âcrire avec libc

**Prototype :**
```c
#include <stdio.h>
size_t fwrite(const void *ptr, size_t size, size_t nmemb, FILE *stream);
```

**Description :**  
√âcrit `nmemb` √©l√©ments de taille `size` vers le stream.

**Exemples :**
```c
// √âcrire une cha√Æne
const char *msg = "Hello\n";
fwrite(msg, 1, strlen(msg), f);

// √âcrire un tableau
int data[10] = {0};
fwrite(data, sizeof(int), 10, f);
```

---

#### `fseek()` - D√©placer le curseur (libc)

**Prototype :**
```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
```

**Description :**  
√âquivalent libc de `lseek()`.

**Whence :**
- `SEEK_SET` : D√©but
- `SEEK_CUR` : Position actuelle
- `SEEK_END` : Fin

**Exemples :**
```c
// Aller au d√©but
fseek(f, 0, SEEK_SET);

// Aller √† la fin
fseek(f, 0, SEEK_END);

// Obtenir la position
long pos = ftell(f);
```

---

#### `ftell()` - Obtenir la position

**Prototype :**
```c
#include <stdio.h>
long ftell(FILE *stream);
```

**Description :**  
Retourne la position actuelle du curseur.

**Exemple : obtenir la taille**
```c
fseek(f, 0, SEEK_END);
long size = ftell(f);
fseek(f, 0, SEEK_SET);
printf("Taille : %ld octets\n", size);
```

---

### üîÄ Redirections et Exec

#### `dup()` - Dupliquer un fd

**Prototype :**
```c
#include <unistd.h>
int dup(int oldfd);
```

**Description :**  
Cr√©e une copie du descripteur.

**Exemple :**
```c
// Sauvegarder stdout
int saved_stdout = dup(1);

// ... rediriger stdout ...

// Restaurer
dup2(saved_stdout, 1);
close(saved_stdout);
```

---

#### `dup2()` - Dupliquer vers un fd sp√©cifique

**Prototype :**
```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
```

**Description :**  
Copie `oldfd` vers `newfd`. Si `newfd` est ouvert, il est ferm√© d'abord.

**Exemples :**
```c
// Rediriger stdout vers un fichier
int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, 1);  // stdout ‚Üí fichier
close(fd);

// Maintenant printf() √©crit dans output.txt
printf("Ce texte va dans output.txt\n");

// Rediriger stderr vers stdout
dup2(1, 2);  // stderr ‚Üí stdout

// Rediriger stdin depuis un fichier
int fd = open("input.txt", O_RDONLY);
dup2(fd, 0);  // stdin ‚Üê fichier
close(fd);

// Maintenant scanf() lit depuis input.txt
```

**Pattern complet : sauvegarder et restaurer**
```c
// Sauvegarder
int saved_stdout = dup(1);
int saved_stderr = dup(2);

// Rediriger
int fd = open("log.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd, 1);
dup2(fd, 2);
close(fd);

// ... code qui √©crit sur stdout/stderr ...

// Restaurer
dup2(saved_stdout, 1);
dup2(saved_stderr, 2);
close(saved_stdout);
close(saved_stderr);
```

---

#### `execl()` et famille - Remplacer le processus

**Prototypes :**
```c
#include <unistd.h>
int execl(const char *path, const char *arg, ..., NULL);
int execlp(const char *file, const char *arg, ..., NULL);
int execle(const char *path, const char *arg, ..., NULL, char *const envp[]);
int execv(const char *path, char *const argv[]);
int execvp(const char *file, char *const argv[]);
int execve(const char *path, char *const argv[], char *const envp[]);
```

**Description :**  
Remplace le processus courant par un nouveau programme. **Ne retourne JAMAIS en cas de succ√®s.**

**Variantes :**
- `l` (list) : Arguments pass√©s un par un ‚Üí `execl("/bin/ls", "ls", "-l", NULL)`
- `v` (vector) : Arguments dans un tableau ‚Üí `execv("/bin/ls", argv)`
- `p` (path) : Cherche dans `$PATH` ‚Üí `execlp("ls", "ls", "-l", NULL)`
- `e` (environment) : Passe un environnement custom

**Exemples :**
```c
// execl : arguments liste
execl("/bin/ls", "ls", "-l", "-a", NULL);
// Si on arrive ici, c'est une erreur
perror("execl");

// execlp : cherche dans PATH
execlp("grep", "grep", "motif", "fichier.txt", NULL);

// execv : arguments tableau
char *argv[] = {"ls", "-l", NULL};
execv("/bin/ls", argv);

// execvp : tableau + PATH
char *argv[] = {"gcc", "-o", "prog", "prog.c", NULL};
execvp("gcc", argv);

// execve : avec environnement custom
char *argv[] = {"prog", NULL};
char *envp[] = {"VAR=valeur", NULL};
execve("./prog", argv, envp);
```

**Points importants :**
- Le processus est **compl√®tement remplac√©**
- Le code apr√®s `exec()` **ne s'ex√©cute jamais** (sauf erreur)
- Les descripteurs de fichiers restent ouverts (sauf `O_CLOEXEC`)
- Les redirections faites avec `dup2()` sont conserv√©es

**Pattern typique : fork + exec**
```c
pid_t pid = fork();

if (pid == 0) {
    // Processus enfant
    execl("/bin/ls", "ls", "-l", NULL);
    perror("execl");  // Seulement si erreur
    exit(1);
}

// Processus parent continue ici
wait(NULL);
```

---

#### `setenv()` / `getenv()` - Variables d'environnement

**Prototypes :**
```c
#include <stdlib.h>
int setenv(const char *name, const char *value, int overwrite);
char *getenv(const char *name);
```

**Exemples :**
```c
// D√©finir une variable
setenv("MY_VAR", "valeur", 1);

// Lire une variable
char *path = getenv("PATH");
if (path) {
    printf("PATH = %s\n", path);
}

// Modifier PATH
char new_path[1000];
snprintf(new_path, sizeof(new_path), "%s:/nouveau/chemin", getenv("PATH"));
setenv("PATH", new_path, 1);
```

---

### üñ•Ô∏è Terminal

#### `ttyname()` - Nom du terminal

**Prototype :**
```c
#include <unistd.h>
char *ttyname(int fd);
```

**Description :**  
Retourne le nom du terminal associ√© au fd.

**Exemple :**
```c
char *tty = ttyname(0);  // Terminal de stdin
printf("Terminal : %s\n", tty);  // Ex: /dev/pts/0
```

---

#### `stty` - Configuration terminal (commande shell)

**Exemples shell :**
```bash
# D√©sactiver l'√©cho (pour mots de passe)
stty -echo

# R√©activer l'√©cho
stty echo

# Mode raw (pas de traitement)
stty raw

# Restaurer mode normal
stty sane
```

**En C (via system) :**
```c
// D√©sactiver √©cho
system("stty -echo");
printf("Mot de passe : ");
fgets(password, sizeof(password), stdin);
system("stty echo");
printf("\n");
```

---

## üì° TP4 - COMMUNICATION INTER-PROCESSUS

### üîî Signaux

#### `signal()` - Capturer un signal

**Prototype :**
```c
#include <signal.h>
typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);
```

**Description :**  
Associe un gestionnaire √† un signal.

**Handlers sp√©ciaux :**
- `SIG_DFL` : Comportement par d√©faut
- `SIG_IGN` : Ignorer le signal

**Exemples :**
```c
void mon_handler(int sig) {
    printf("Signal %d re√ßu\n", sig);
    // PAS de printf en vrai ! (non async-signal-safe)
}

// Capturer Ctrl-C
signal(SIGINT, mon_handler);

// Ignorer SIGPIPE
signal(SIGPIPE, SIG_IGN);

// Restaurer comportement par d√©faut
signal(SIGTERM, SIG_DFL);
```

**‚ö†Ô∏è Attention : `printf()` dans un handler est DANGEREUX**
```c
// ‚ùå Mauvais (non async-signal-safe)
void handler(int sig) {
    printf("Signal %d\n", sig);
}

// ‚úì Mieux : utiliser write()
void handler(int sig) {
    char msg[] = "Signal re√ßu\n";
    write(2, msg, sizeof(msg)-1);
}

// ‚úì Ou : utiliser un flag global
volatile sig_atomic_t signal_received = 0;

void handler(int sig) {
    signal_received = sig;
}
```

---

#### `kill()` - Envoyer un signal

**Prototype :**
```c
#include <signal.h>
int kill(pid_t pid, int sig);
```

**Description :**  
Envoie un signal √† un processus.

**Exemples :**
```c
// Envoyer SIGUSR1 au processus 1234
kill(1234, SIGUSR1);

// Envoyer SIGTERM (terminaison propre)
kill(pid, SIGTERM);

// Envoyer SIGKILL (forc√©)
kill(pid, SIGKILL);

// Envoyer √† soi-m√™me
kill(getpid(), SIGUSR1);

// Tester si un processus existe (signal 0)
if (kill(pid, 0) == 0) {
    printf("Processus %d existe\n", pid);
} else {
    printf("Processus %d n'existe pas\n", pid);
}
```

---

#### `pause()` - Attendre un signal

**Prototype :**
```c
#include <unistd.h>
int pause(void);
```

**Description :**  
Suspend le processus jusqu'√† r√©ception d'un signal.

**Exemple :**
```c
printf("En attente d'un signal...\n");
pause();  // Bloque ici
printf("Signal re√ßu, on continue\n");
```

---

#### `alarm()` - Programmer une alarme

**Prototype :**
```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds);
```

**Description :**  
Programme un `SIGALRM` dans N secondes. Une seule alarme √† la fois.

**Exemples :**
```c
void alarm_handler(int sig) {
    write(1, "TIMEOUT!\n", 9);
}

signal(SIGALRM, alarm_handler);
alarm(5);  // SIGALRM dans 5 secondes

// Annuler une alarme
alarm(0);

// Timeout avec pause
signal(SIGALRM, alarm_handler);
alarm(10);
pause();  // Attendre maximum 10 secondes
```

**Pattern : timeout sur une op√©ration**
```c
volatile sig_atomic_t timeout = 0;

void alarm_handler(int sig) {
    timeout = 1;
}

signal(SIGALRM, alarm_handler);
alarm(5);

while (!timeout) {
    // Faire quelque chose
    if (operation_terminee) break;
}

if (timeout) {
    printf("Timeout!\n");
}
```

---

### üö∞ Pipes

#### `pipe()` - Cr√©er un pipe anonyme

**Prototype :**
```c
#include <unistd.h>
int pipe(int pipefd[2]);
```

**Description :**  
Cr√©e un pipe (tuyau) unidirectionnel.

**Param√®tres :**
- `pipefd[0]` : Descripteur de **lecture**
- `pipefd[1]` : Descripteur d'**√©criture**

**Retour :**
- **Succ√®s** : `0`
- **Erreur** : `-1`

**Exemples :**
```c
int pipefd[2];

if (pipe(pipefd) < 0) {
    perror("pipe");
    return 1;
}

// Maintenant :
// pipefd[0] = lecture
// pipefd[1] = √©criture

// √âcrire dans le pipe
write(pipefd[1], "Hello", 5);

// Lire depuis le pipe
char buf[10];
read(pipefd[0], buf, 5);

// TOUJOURS fermer les extr√©mit√©s inutilis√©es
close(pipefd[0]);
close(pipefd[1]);
```

**Pattern : communication parent/enfant**
```c
int pipefd[2];
pipe(pipefd);

pid_t pid = fork();

if (pid == 0) {
    // ENFANT : √©crire
    close(pipefd[0]);  // Fermer lecture (inutilis√©)
    
    write(pipefd[1], "Message de l'enfant", 19);
    
    close(pipefd[1]);
    exit(0);
    
} else {
    // PARENT : lire
    close(pipefd[1]);  // Fermer √©criture (inutilis√©)
    
    char buf[100];
    ssize_t n = read(pipefd[0], buf, sizeof(buf)-1);
    buf[n] = '\0';
    printf("Re√ßu : %s\n", buf);
    
    close(pipefd[0]);
    wait(NULL);
}
```

**‚ö†Ô∏è R√®gles importantes :**
1. **Fermer les fd inutilis√©s** : Si on lit, fermer l'√©criture et vice-versa
2. **Fermer dans TOUS les processus** : Parent ET enfant
3. `read()` bloque si le pipe est vide et qu'un √©crivain existe
4. `read()` retourne 0 si tous les √©crivains ont ferm√©
5. `write()` provoque SIGPIPE si tous les lecteurs ont ferm√©

---

#### `mkfifo()` - Cr√©er un FIFO (pipe nomm√©)

**Prototype :**
```c
#include <sys/stat.h>
int mkfifo(const char *pathname, mode_t mode);
```

**Description :**  
Cr√©e un FIFO (fichier sp√©cial de type pipe).

**Exemples :**
```c
// Cr√©er un FIFO avec permissions 0666
if (mkfifo("/tmp/myfifo", 0666) < 0) {
    perror("mkfifo");
    return 1;
}

// Ouvrir en √©criture (bloque jusqu'√† ce qu'un lecteur ouvre)
int fd = open("/tmp/myfifo", O_WRONLY);
write(fd, "Hello", 5);
close(fd);

// Dans un autre processus : lecture
int fd = open("/tmp/myfifo", O_RDONLY);
char buf[10];
read(fd, buf, 5);
close(fd);

// Supprimer le FIFO
unlink("/tmp/myfifo");
```

**Diff√©rence FIFO vs fichier :**
- **FIFO** : Les donn√©es transitent (pas de stockage disque)
- **Fichier** : Les donn√©es sont stock√©es

---

### üîß Contr√¥le avanc√©

#### `fcntl()` - Contr√¥le de fichier

**Prototype :**
```c
#include <fcntl.h>
int fcntl(int fd, int cmd, ...);
```

**Description :**  
Op√©rations de contr√¥le sur un fd.

**Commandes utiles :**
- `F_GETFL` : Obtenir les flags
- `F_SETFL` : D√©finir les flags
- `F_GETPIPE_SZ` : Taille du pipe (Linux)
- `F_SETPIPE_SZ` : Changer la taille du pipe

**Exemples :**
```c
// Obtenir la taille d'un pipe
int size = fcntl(pipefd[0], F_GETPIPE_SZ);
printf("Taille du pipe : %d octets\n", size);

// Rendre un fd non-bloquant
int flags = fcntl(fd, F_GETFL);
fcntl(fd, F_SETFL, flags | O_NONBLOCK);

// Tester si un fd est non-bloquant
int flags = fcntl(fd, F_GETFL);
if (flags & O_NONBLOCK) {
    printf("Non-bloquant\n");
}
```

---

## üî§ Types de donn√©es

### `ssize_t` - Taille sign√©e

**Description :**  
Type **sign√©** pour les tailles. Peut contenir `-1` pour les erreurs.

**Utilis√© par :**
- `read()`, `write()` : retourne le nombre d'octets ou `-1`

**Exemple :**
```c
ssize_t n = read(fd, buf, 100);
if (n < 0) {
    perror("read");  // Erreur
} else if (n == 0) {
    printf("EOF\n");  // Fin de fichier
} else {
    printf("Lu %zd octets\n", n);  // %zd pour ssize_t
}
```

---

### `size_t` - Taille non sign√©e

**Description :**  
Type **non sign√©** pour les tailles. Ne peut pas √™tre n√©gatif.

**Utilis√© par :**
- `malloc()`, `strlen()`, `fread()`, `fwrite()`

**Exemple :**
```c
size_t len = strlen("Hello");  // 5
printf("Longueur : %zu\n", len);  // %zu pour size_t

char *buf = malloc(100 * sizeof(char));
size_t n = fread(buf, 1, 100, f);
```

---

### `off_t` - Offset dans un fichier

**Description :**  
Type pour les positions/tailles de fichier. Peut √™tre tr√®s grand (64 bits).

**Utilis√© par :**
- `lseek()`, `fstat()` (champ `st_size`)

**Exemple :**
```c
off_t pos = lseek(fd, 0, SEEK_CUR);  // Position actuelle
printf("Position : %ld\n", (long)pos);  // Cast en long pour printf

off_t size = lseek(fd, 0, SEEK_END);
printf("Taille : %ld octets\n", (long)size);
```

---

### `pid_t` - Process ID

**Description :**  
Type pour les IDs de processus.

**Utilis√© par :**
- `fork()`, `getpid()`, `getppid()`, `kill()`, `wait()`

**Exemple :**
```c
pid_t pid = fork();
if (pid == 0) {
    printf("Je suis l'enfant, PID = %d\n", getpid());
} else {
    printf("Je suis le parent, mon enfant a le PID %d\n", pid);
}
```

---

### `mode_t` - Permissions

**Description :**  
Type pour les permissions de fichiers.

**Valeurs courantes :**
```c
0644  // rw-r--r--  (Propri√©taire: lecture/√©criture, autres: lecture)
0666  // rw-rw-rw-  (Tous: lecture/√©criture)
0755  // rwxr-xr-x  (Propri√©taire: tout, autres: lecture/ex√©cution)
0777  // rwxrwxrwx  (Tous: tout)
```

**Exemple :**
```c
int fd = open("file.txt", O_CREAT | O_WRONLY, 0644);
mkfifo("/tmp/pipe", 0666);
```

---

## üîç `perror()` - Afficher l'erreur

**Prototype :**
```c
#include <stdio.h>
void perror(const char *s);
```

**Description :**  
Affiche un message d'erreur bas√© sur `errno` (variable globale).

**Fonctionnement :**
1. Affiche la cha√Æne `s` suivie de `: `
2. Affiche le message d'erreur correspondant √† `errno`
3. Affiche un retour √† la ligne

**Exemples :**
```c
int fd = open("inexistant.txt", O_RDONLY);
if (fd < 0) {
    perror("open");
    // Affiche : "open: No such file or directory"
    return 1;
}

if (write(fd, buf, 100) < 0) {
    perror("write");
    // Affiche : "write: Bad file descriptor" (si fd ferm√©)
}
```

**Alternative : `strerror()`**
```c
#include <string.h>
#include <errno.h>

if (fd < 0) {
    fprintf(stderr, "Erreur open : %s\n", strerror(errno));
}
```

---

## üìù R√©capitulatif : fd vs FILE*

### Descripteur de fichier (fd)

**Type :** `int` (nombre)

**Fonctions :**
- `open()`, `close()`
- `read()`, `write()`
- `lseek()`
- `dup()`, `dup2()`
- `pipe()`
- `fcntl()`

**Caract√©ristiques :**
- ‚úì Appels syst√®me directs (pas de surcouche)
- ‚úì Contr√¥le total (flags, permissions, non-bloquant...)
- ‚úì N√©cessaire pour pipes, sockets, redirections
- ‚úó Pas de buffering (moins performant pour petites lectures)
- ‚úó API plus bas niveau

**Quand l'utiliser :**
- Pipes et FIFO
- Redirections (`dup2`)
- Contr√¥le pr√©cis (non-bloquant, etc.)
- Communication inter-processus

---

### Flux standard (FILE*)

**Type :** `FILE*` (pointeur vers structure)

**Fonctions :**
- `fopen()`, `fclose()`
- `fread()`, `fwrite()`
- `fseek()`, `ftell()`
- `fprintf()`, `fscanf()`
- `fgets()`, `fputs()`

**Caract√©ristiques :**
- ‚úì Buffering automatique (performant)
- ‚úì API haut niveau (plus simple)
- ‚úì Fonctions format√©es (`fprintf`, `fscanf`)
- ‚úó Moins de contr√¥le
- ‚úó Pas pour pipes/redirections

**Quand l'utiliser :**
- Fichiers r√©guliers simples
- Lecture/√©criture texte
- Besoin de formatting (`fprintf`, etc.)

---

## üéØ Patterns courants

### Pattern 1 : Lire un fichier entier

```c
int fd = open("fichier.txt", O_RDONLY);
off_t size = lseek(fd, 0, SEEK_END);
lseek(fd, 0, SEEK_SET);

char *buffer = malloc(size + 1);
read(fd, buffer, size);
buffer[size] = '\0';

close(fd);
// Utiliser buffer...
free(buffer);
```

### Pattern 2 : Copier un fichier

```c
int src = open("source.txt", O_RDONLY);
int dst = open("dest.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);

char buf[4096];
ssize_t n;
while ((n = read(src, buf, sizeof(buf))) > 0) {
    write(dst, buf, n);
}

close(src);
close(dst);
```

### Pattern 3 : Redirection stdin/stdout

```c
// Rediriger stdin depuis un fichier
int fd_in = open("input.txt", O_RDONLY);
dup2(fd_in, 0);
close(fd_in);

// Rediriger stdout vers un fichier
int fd_out = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
dup2(fd_out, 1);
close(fd_out);

// Maintenant scanf lit input.txt et printf √©crit output.txt
```

### Pattern 4 : Pipe entre processus

```c
int pipefd[2];
pipe(pipefd);

if (fork() == 0) {
    // Enfant : √©crire
    close(pipefd[0]);
    write(pipefd[1], "data", 4);
    close(pipefd[1]);
    exit(0);
} else {
    // Parent : lire
    close(pipefd[1]);
    char buf[10];
    read(pipefd[0], buf, 4);
    close(pipefd[0]);
    wait(NULL);
}
```

### Pattern 5 : Capturer un signal avec flag

```c
volatile sig_atomic_t stop = 0;

void handler(int sig) {
    stop = 1;
}

signal(SIGINT, handler);

while (!stop) {
    // Traitement...
}

printf("Arr√™t demand√©\n");
```

---

## üö® Erreurs courantes et solutions

### Erreur 1 : Oublier de fermer les fd

```c
// ‚ùå Mauvais
int fd = open("file.txt", O_RDONLY);
read(fd, buf, 100);
// Oubli√© close(fd) !

// ‚úì Bon
int fd = open("file.txt", O_RDONLY);
read(fd, buf, 100);
close(fd);
```

### Erreur 2 : Ne pas v√©rifier les retours

```c
// ‚ùå Mauvais
int fd = open("file.txt", O_RDONLY);
read(fd, buf, 100);  // Et si open a √©chou√© ?

// ‚úì Bon
int fd = open("file.txt", O_RDONLY);
if (fd < 0) {
    perror("open");
    return 1;
}
```

### Erreur 3 : Buffer non allou√©

```c
// ‚ùå Mauvais
char *buf;
read(fd, buf, 100);  // Segfault !

// ‚úì Bon
char buf[100];
read(fd, buf, 100);

// Ou :
char *buf = malloc(100);
read(fd, buf, 100);
free(buf);
```

### Erreur 4 : Pipe mal ferm√©

```c
// ‚ùå Mauvais
int pipefd[2];
pipe(pipefd);
fork();
// Les deux processus ont les deux extr√©mit√©s ouvertes
// read() va bloquer ind√©finiment

// ‚úì Bon
pipe(pipefd);
if (fork() == 0) {
    close(pipefd[0]);  // Enfant ferme lecture
    write(pipefd[1], "data", 4);
    close(pipefd[1]);
} else {
    close(pipefd[1]);  // Parent ferme √©criture
    read(pipefd[0], buf, 4);
    close(pipefd[0]);
}
```

### Erreur 5 : printf dans un signal handler

```c
// ‚ùå DANGEREUX
void handler(int sig) {
    printf("Signal %d\n", sig);  // Non async-signal-safe !
}

// ‚úì Bon
volatile sig_atomic_t received = 0;

void handler(int sig) {
    received = sig;
}

// Dans le main
if (received) {
    printf("Signal %d re√ßu\n", received);
}
```

---

## üìö Aide-m√©moire final

### Flux noyau
```c
open()   ‚Üí Ouvrir fichier ‚Üí int fd
close()  ‚Üí Fermer fd
read()   ‚Üí Lire ‚Üí ssize_t (nb octets ou -1)
write()  ‚Üí √âcrire ‚Üí ssize_t
lseek()  ‚Üí D√©placer curseur ‚Üí off_t (position)
fstat()  ‚Üí Infos fichier ‚Üí struct stat
```

### Flux libc
```c
fopen()  ‚Üí Ouvrir ‚Üí FILE*
fclose() ‚Üí Fermer
fread()  ‚Üí Lire ‚Üí size_t (nb √©l√©ments)
fwrite() ‚Üí √âcrire ‚Üí size_t
fseek()  ‚Üí D√©placer ‚Üí int
ftell()  ‚Üí Position ‚Üí long
```

### Redirections
```c
dup()    ‚Üí Dupliquer fd
dup2()   ‚Üí Dupliquer vers fd sp√©cifique
execl()  ‚Üí Remplacer processus (liste args)
execv()  ‚Üí Remplacer processus (tableau args)
```

### Signaux
```c
signal() ‚Üí Capturer signal
kill()   ‚Üí Envoyer signal
pause()  ‚Üí Attendre signal
alarm()  ‚Üí Alarme
```

### Pipes
```c
pipe()   ‚Üí Cr√©er pipe anonyme
mkfifo() ‚Üí Cr√©er FIFO (pipe nomm√©)
fcntl()  ‚Üí Contr√¥ler fd/pipe
```

---

**Auteur :** Guide ISE TP3/TP4 - ENSIIE 2025