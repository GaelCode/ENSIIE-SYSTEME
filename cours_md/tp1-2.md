# Commandes et Concepts ISE - TP1 et TP2

Guide complet de toutes les commandes Shell utilis√©es dans les TPs 1 et 2

---

## üìÇ TP1 - BASES DU SHELL

### üß≠ Navigation

#### `cd` - Change Directory

**Description :**  
Change le r√©pertoire courant.

**Syntaxe :**
```bash
cd [r√©pertoire]
```

**Exemples :**
```bash
cd /home/user           # Chemin absolu
cd Documents            # Chemin relatif
cd ..                   # Remonter d'un niveau
cd ../..                # Remonter de 2 niveaux
cd ~                    # Aller au HOME
cd ~/Documents          # HOME + sous-dossier
cd -                    # R√©pertoire pr√©c√©dent
cd                      # Aller au HOME (sans argument)
```

**Astuces :**
- `~` = votre r√©pertoire HOME (`/home/username`)
- `.` = r√©pertoire courant
- `..` = r√©pertoire parent
- `-` = r√©pertoire pr√©c√©dent (bascule entre 2 dossiers)

---

#### `pwd` - Print Working Directory

**Description :**  
Affiche le r√©pertoire courant (o√π vous √™tes).

**Syntaxe :**
```bash
pwd
```

**Exemple :**
```bash
$ pwd
/home/user/Documents
```

**Option utile :**
```bash
pwd -P              # Affiche le chemin physique (sans liens symboliques)
```

---

#### `ls` - List

**Description :**  
Liste les fichiers et r√©pertoires.

**Syntaxe :**
```bash
ls [options] [chemin]
```

**Options courantes :**
```bash
ls                  # Liste simple
ls -l               # Format long (d√©tails)
ls -a               # Affiche les fichiers cach√©s (commencent par .)
ls -la              # Tout en format long
ls -lh              # Tailles lisibles (K, M, G)
ls -lt              # Trier par date (plus r√©cent en premier)
ls -ltr             # Trier par date (plus ancien en premier)
ls -R               # R√©cursif (sous-dossiers)
ls -d */            # Seulement les r√©pertoires
ls *.txt            # Seulement les .txt (glob pattern)
```

**Exemple d√©taill√© :**
```bash
$ ls -lh
total 12K
drwxr-xr-x 2 user group 4.0K Nov 18 10:00 dossier
-rw-r--r-- 1 user group 1.2K Nov 18 09:30 fichier.txt
-rwxr-xr-x 1 user group  512 Nov 17 14:20 script.sh
```

**Comprendre les permissions :**
```
-rwxr-xr-x
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ Autres: ex√©cution
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ Autres: √©criture (-)
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ Autres: lecture
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ Groupe: ex√©cution
‚îÇ‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Groupe: √©criture (-)
‚îÇ‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Groupe: lecture
‚îÇ‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire: ex√©cution
‚îÇ‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire: √©criture
‚îÇ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Propri√©taire: lecture
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Type: - (fichier), d (r√©pertoire), l (lien)
```

---

### üìù Manipulation de fichiers

#### `mkdir` - Make Directory

**Description :**  
Cr√©e un ou plusieurs r√©pertoires.

**Syntaxe :**
```bash
mkdir [options] nom_r√©pertoire
```

**Options importantes :**
```bash
mkdir dossier                    # Cr√©er un dossier
mkdir -p chemin/sous/dossier     # Cr√©er toute l'arborescence (parents)
mkdir -v dossier                 # Verbose (affiche ce qui est cr√©√©)
mkdir -m 755 dossier             # Avec permissions sp√©cifiques
mkdir dossier1 dossier2          # Cr√©er plusieurs dossiers
```

**Exemples :**
```bash
# Cr√©er une arborescence complexe
mkdir -p projet/{src,docs,tests}

# R√©sultat :
# projet/
#   ‚îú‚îÄ‚îÄ src/
#   ‚îú‚îÄ‚îÄ docs/
#   ‚îî‚îÄ‚îÄ tests/

# Cr√©er avec permissions
mkdir -m 700 secret              # rwx------ (propri√©taire seulement)
```

---

#### `touch` - Cr√©er/modifier fichier

**Description :**  
Cr√©e un fichier vide OU met √† jour la date de modification.

**Syntaxe :**
```bash
touch fichier
```

**Exemples :**
```bash
touch fichier.txt               # Cr√©er fichier vide
touch file1 file2 file3         # Cr√©er plusieurs fichiers
touch -d "2025-01-01" file      # Changer la date
touch -t 202501011200 file      # Format YYYYMMDDhhmm
```

---

#### `cp` - Copy

**Description :**  
Copie des fichiers ou r√©pertoires.

**Syntaxe :**
```bash
cp [options] source destination
```

**Options importantes :**
```bash
cp file1 file2              # Copier file1 vers file2
cp file1 dir/               # Copier dans un r√©pertoire
cp -r dir1 dir2             # Copier r√©cursif (r√©pertoires)
cp -v file1 file2           # Verbose (affiche ce qui est fait)
cp -i file1 file2           # Interactif (demande avant √©crasement)
cp -p file1 file2           # Pr√©server permissions et dates
cp -a dir1 dir2             # Archive (= -r -p + liens)
cp file{1,2,3} dir/         # Copier plusieurs fichiers
```

**Exemples :**
```bash
# Copier avec sauvegarde
cp -b file1 file2           # Cr√©e file2~ en backup

# Copier seulement si plus r√©cent
cp -u source dest

# Copier en pr√©servant tout
cp -a /home/user/data /backup/
```

---

#### `mv` - Move (d√©placer/renommer)

**Description :**  
D√©place OU renomme des fichiers/r√©pertoires.

**Syntaxe :**
```bash
mv [options] source destination
```

**Exemples :**
```bash
mv ancien nouveau           # Renommer
mv file dir/                # D√©placer dans un r√©pertoire
mv -v file dir/             # Verbose
mv -i file dir/             # Interactif (demande avant √©crasement)
mv file1 file2 file3 dir/   # D√©placer plusieurs fichiers
```

**Astuces :**
```bash
# Renommer avec extension
mv file file.txt

# D√©placer en renommant
mv /tmp/old.txt /home/user/new.txt

# D√©placer r√©pertoire
mv old_name/ new_name/
```

---

#### `rm` - Remove

**Description :**  
Supprime des fichiers ou r√©pertoires. **‚ö†Ô∏è IRR√âVERSIBLE !**

**Syntaxe :**
```bash
rm [options] fichier
```

**Options :**
```bash
rm file                     # Supprimer un fichier
rm -r dir/                  # Supprimer r√©cursif (r√©pertoire)
rm -f file                  # Force (pas de confirmation)
rm -rf dir/                 # Supprimer r√©pertoire force (DANGER!)
rm -i file                  # Interactif (demande confirmation)
rm -v file                  # Verbose
rm *.txt                    # Supprimer tous les .txt
```

**‚ö†Ô∏è Commandes DANGEREUSES :**
```bash
rm -rf /                    # D√âTRUIT LE SYST√àME (ne JAMAIS faire)
rm -rf *                    # Supprime tout dans le dossier actuel
rm -rf ~                    # Supprime votre HOME
```

**Alternatives s√ªres :**
```bash
# V√©rifier d'abord ce qui sera supprim√©
ls *.txt
# Puis supprimer
rm *.txt

# Utiliser trash (si disponible)
trash file                  # Envoie √† la corbeille au lieu de supprimer
```

---

#### `cat` - Concatenate

**Description :**  
Affiche le contenu d'un ou plusieurs fichiers.

**Syntaxe :**
```bash
cat [options] fichier
```

**Utilisations :**
```bash
cat file.txt                # Afficher le contenu
cat file1 file2             # Afficher plusieurs fichiers
cat file1 file2 > combined  # Concat√©ner dans un nouveau fichier
cat > file.txt              # Cr√©er fichier (Ctrl-D pour terminer)
cat >> file.txt             # Ajouter √† un fichier
cat -n file.txt             # Afficher avec num√©ros de ligne
cat -A file.txt             # Afficher caract√®res invisibles
```

**Exemples pratiques :**
```bash
# Cr√©er un fichier rapidement
cat > test.txt << EOF
Ligne 1
Ligne 2
EOF

# Afficher avec num√©rotation
cat -n script.sh

# Voir les caract√®res de fin de ligne
cat -A file.txt             # $ = fin de ligne, ^I = tab
```

---

#### `echo` - Afficher du texte

**Description :**  
Affiche une ligne de texte.

**Syntaxe :**
```bash
echo [options] "texte"
```

**Options :**
```bash
echo "Hello"                # Affiche Hello
echo -n "Hello"             # Sans retour √† la ligne
echo -e "Line1\nLine2"      # Interpr√©ter \n, \t, etc.
echo $VAR                   # Affiche la valeur d'une variable
echo "Texte" > file.txt     # √âcrire dans un fichier
echo "Texte" >> file.txt    # Ajouter √† un fichier
```

**S√©quences d'√©chappement avec `-e` :**
```bash
echo -e "Hello\nWorld"      # Saut de ligne
echo -e "A\tB"              # Tabulation
echo -e "Hello\c"           # Pas de newline final (comme -n)
echo -e "\033[31mRouge\033[0m"  # Couleur rouge
```

**Exemples pratiques :**
```bash
# Cr√©er fichier avec 1000 'A'
echo -n "$(printf 'A%.0s' {1..1000})" > file.txt

# Afficher variables
echo "PATH = $PATH"
echo "User = $USER"
echo "Home = $HOME"

# Afficher avec guillemets
echo 'Valeur: $VAR'         # Affiche litt√©ralement: Valeur: $VAR
echo "Valeur: $VAR"         # Affiche la valeur de $VAR
```

---

### üîÄ Redirections

#### `>` - Redirection stdout (√©crasement)

**Description :**  
Redirige la sortie vers un fichier (√âCRASE le contenu).

**Exemples :**
```bash
ls > liste.txt              # √âcraser liste.txt avec la sortie de ls
echo "Hello" > file.txt     # Cr√©er/√©craser file.txt
cat file1 > file2           # Copier file1 vers file2 (√©crase)
```

---

#### `>>` - Redirection stdout (ajout)

**Description :**  
Redirige la sortie vers un fichier (AJOUTE √† la fin).

**Exemples :**
```bash
echo "Line 1" > file.txt    # Cr√©er
echo "Line 2" >> file.txt   # Ajouter
echo "Line 3" >> file.txt   # Ajouter encore
```

---

#### `<` - Redirection stdin

**Description :**  
Redirige l'entr√©e depuis un fichier.

**Exemples :**
```bash
wc -l < file.txt            # Compter lignes depuis file.txt
sort < unsorted.txt         # Trier le contenu de unsorted.txt
```

---

#### `2>` - Redirection stderr

**Description :**  
Redirige les ERREURS vers un fichier.

**Exemples :**
```bash
ls /inexistant 2> erreurs.txt       # Erreurs dans erreurs.txt
command 2> /dev/null                # Ignorer les erreurs
```

---

#### `&>` ou `2>&1` - Redirection tout

**Description :**  
Redirige stdout ET stderr vers le m√™me fichier.

**Exemples :**
```bash
command &> tout.txt                 # Syntaxe bash moderne
command > tout.txt 2>&1             # Syntaxe portable

# S√©parer stdout et stderr
command > sortie.txt 2> erreurs.txt

# Tout dans le m√™me fichier
command > log.txt 2>&1

# Ignorer tout
command &> /dev/null
```

---

#### `|` - Pipe

**Description :**  
Connecte la sortie d'une commande √† l'entr√©e de la suivante.

**Exemples :**
```bash
ls | wc -l                          # Compter les fichiers
cat file | grep "motif"             # Filtrer
ps aux | grep firefox               # Trouver processus
history | tail -n 10                # 10 derni√®res commandes

# Cha√Æne complexe
cat /var/log/syslog | grep "error" | wc -l
```

---

#### `|&` - Pipe tout (stdout + stderr)

**Description :**  
Pipe stdout ET stderr (bash 4+).

**Exemples :**
```bash
command |& grep "error"             # Pipe tout
command 2>&1 | grep "error"         # √âquivalent portable
```

---

### üîç Recherche et filtrage

#### `grep` - Recherche de motif

**Description :**  
Recherche des lignes contenant un motif.

**Syntaxe :**
```bash
grep [options] motif fichier
```

**Options importantes :**
```bash
grep "motif" file               # Lignes contenant "motif"
grep -i "motif" file            # Insensible √† la casse
grep -v "motif" file            # Lignes NE contenant PAS "motif"
grep -n "motif" file            # Avec num√©ros de ligne
grep -r "motif" dir/            # R√©cursif dans r√©pertoire
grep -l "motif" *.txt           # Seulement noms de fichiers
grep -c "motif" file            # Compter les occurrences
grep -A 3 "motif" file          # 3 lignes APR√àS
grep -B 3 "motif" file          # 3 lignes AVANT
grep -C 3 "motif" file          # 3 lignes avant ET apr√®s
grep -E "mot1|mot2" file        # Regex √©tendu (OU)
grep -w "mot" file              # Mot entier seulement
grep "^debut" file              # Ligne commen√ßant par "debut"
grep "fin$" file                # Ligne finissant par "fin"
```

**Exemples pratiques :**
```bash
# Trouver dans des logs
grep "ERROR" /var/log/syslog

# Trouver et afficher contexte
grep -C 2 "function" script.sh

# Compter occurrences
grep -c "TODO" *.c

# Recherche r√©cursive
grep -r "FIXME" src/

# Exclure des fichiers
grep --exclude="*.log" "motif" *

# Recherche avec regex
grep -E "[0-9]{3}-[0-9]{3}-[0-9]{4}" contacts.txt  # Num√©ro t√©l√©phone
```

---

#### `find` - Trouver des fichiers

**Description :**  
Recherche de fichiers selon crit√®res.

**Syntaxe :**
```bash
find [chemin] [crit√®res] [actions]
```

**Crit√®res courants :**
```bash
find . -name "*.txt"            # Par nom
find . -iname "*.txt"           # Insensible casse
find . -type f                  # Fichiers r√©guliers
find . -type d                  # R√©pertoires
find . -size +10M               # Taille > 10 Mo
find . -size -1k                # Taille < 1 Ko
find . -mtime -7                # Modifi√© dans les 7 derniers jours
find . -mtime +30               # Modifi√© il y a plus de 30 jours
find . -user john               # Appartenant √† john
find . -perm 644                # Permissions exactes
find . -empty                   # Fichiers/dossiers vides
```

**Actions :**
```bash
find . -name "*.log" -delete    # Supprimer
find . -name "*.txt" -exec cat {} \;        # Ex√©cuter commande
find . -type f -exec chmod 644 {} \;        # Changer permissions
find . -name "*.c" -exec grep "main" {} +   # grep sur r√©sultats
```

**Exemples pratiques :**
```bash
# Trouver et supprimer
find . -name "*.tmp" -delete

# Trouver gros fichiers
find /home -size +100M

# Trouver et afficher
find . -name "*.sh" -exec ls -lh {} \;

# Trouver fichiers modifi√©s aujourd'hui
find . -type f -mtime 0

# Combiner crit√®res
find . -type f -name "*.c" -size +10k
```

---

#### `wc` - Word Count

**Description :**  
Compte lignes, mots, caract√®res.

**Syntaxe :**
```bash
wc [options] fichier
```

**Options :**
```bash
wc file                     # Lignes, mots, octets
wc -l file                  # Nombre de lignes
wc -w file                  # Nombre de mots
wc -c file                  # Nombre d'octets
wc -m file                  # Nombre de caract√®res
wc -L file                  # Longueur ligne la plus longue
```

**Exemples :**
```bash
# Compter lignes d'un fichier
wc -l script.sh

# Compter fichiers dans un dossier
ls | wc -l

# Compter lignes de code
find . -name "*.c" -exec wc -l {} + | tail -1
```

---

#### `head` / `tail` - D√©but / Fin de fichier

**Description :**  
Affiche les premi√®res/derni√®res lignes d'un fichier.

**Syntaxe :**
```bash
head [options] fichier
tail [options] fichier
```

**Options :**
```bash
head file                   # 10 premi√®res lignes (d√©faut)
head -n 20 file             # 20 premi√®res lignes
head -20 file               # Idem (syntaxe courte)
head -c 100 file            # 100 premiers octets

tail file                   # 10 derni√®res lignes
tail -n 20 file             # 20 derni√®res lignes
tail -f file                # Suivre en temps r√©el (logs)
tail -F file                # Idem + g√®re rotation de fichier
tail -n +10 file            # Depuis la ligne 10 jusqu'√† la fin
```

**Exemples pratiques :**
```bash
# Voir d√©but d'un log
head -50 /var/log/syslog

# Suivre un log en direct
tail -f /var/log/apache2/access.log

# Extraire lignes 20 √† 30
head -30 file | tail -10

# Lire tout sauf les 5 premi√®res lignes
tail -n +6 file
```

---

### ‚úÇÔ∏è Traitement de texte

#### `cut` - D√©couper colonnes

**Description :**  
Extrait des colonnes d'un fichier.

**Syntaxe :**
```bash
cut [options] fichier
```

**Options :**
```bash
cut -d: -f1 file            # 1√®re colonne (d√©limiteur :)
cut -d, -f1,3 file          # Colonnes 1 et 3 (d√©limiteur ,)
cut -d: -f1-3 file          # Colonnes 1 √† 3
cut -c1-10 file             # Caract√®res 1 √† 10
cut -c1,5,10 file           # Caract√®res 1, 5 et 10
```

**Exemples :**
```bash
# Extraire usernames de /etc/passwd
cut -d: -f1 /etc/passwd

# Extraire IPs d'un log
cut -d' ' -f1 access.log

# Premier champ de CSV
cut -d, -f1 data.csv
```

---

#### `sort` - Trier

**Description :**  
Trie les lignes d'un fichier.

**Syntaxe :**
```bash
sort [options] fichier
```

**Options :**
```bash
sort file                   # Tri alphab√©tique
sort -n file                # Tri num√©rique
sort -r file                # Ordre inverse (reverse)
sort -u file                # Unique (supprime doublons)
sort -k 2 file              # Trier sur 2e colonne
sort -t: -k 3 file          # D√©limiteur : et colonne 3
sort -h file                # Tri "human" (1K, 1M, 1G...)
```

**Exemples :**
```bash
# Trier et d√©dupliquer
sort -u file

# Trier num√©riquement
sort -n numbers.txt

# Trier sur colonne sp√©cifique
sort -t: -k3 -n /etc/passwd     # Tri par UID

# Trier par taille (human-readable)
ls -lh | sort -k 5 -h
```

---

#### `uniq` - Supprimer doublons

**Description :**  
Supprime les lignes cons√©cutives identiques. **‚ö†Ô∏è N√©cessite un tri pr√©alable !**

**Syntaxe :**
```bash
uniq [options] fichier
```

**Options :**
```bash
uniq file                   # Supprimer doublons cons√©cutifs
uniq -c file                # Compter occurrences
uniq -d file                # Seulement les doublons
uniq -u file                # Seulement les lignes uniques
uniq -i file                # Insensible √† la casse
```

**Exemples :**
```bash
# Pattern classique : sort + uniq
sort file | uniq

# Compter occurrences
sort file | uniq -c

# Trier par nombre d'occurrences
sort file | uniq -c | sort -rn

# Trouver les doublons
sort file | uniq -d
```

---

#### `sed` - Stream Editor

**Description :**  
√âditeur de flux pour transformer du texte.

**Syntaxe :**
```bash
sed 's/ancien/nouveau/' fichier
```

**Op√©rations courantes :**
```bash
sed 's/old/new/' file           # Remplacer 1√®re occurrence par ligne
sed 's/old/new/g' file          # Remplacer toutes les occurrences
sed 's/old/new/gi' file         # Idem insensible casse
sed '5s/old/new/' file          # Seulement ligne 5
sed '/pattern/s/old/new/' file  # Sur lignes contenant "pattern"
sed '/pattern/d' file           # Supprimer lignes avec "pattern"
sed -n '5,10p' file             # Afficher lignes 5 √† 10
sed -n '/pattern/p' file        # Afficher lignes avec "pattern"
sed -i 's/old/new/g' file       # Modifier le fichier en place
sed -i.bak 's/old/new/g' file   # Idem + backup
```

**Exemples pratiques :**
```bash
# Remplacer dans un fichier
sed -i 's/http/https/g' config.txt

# Supprimer lignes vides
sed '/^$/d' file

# Supprimer commentaires
sed '/^#/d' file

# Ajouter au d√©but de chaque ligne
sed 's/^/prefix_/' file

# Ajouter √† la fin de chaque ligne
sed 's/$/_suffix/' file

# Remplacer seulement lignes 10-20
sed '10,20s/old/new/g' file
```

---

#### `awk` - Traitement avanc√©

**Description :**  
Langage de traitement de texte puissant.

**Syntaxe de base :**
```bash
awk 'pattern {action}' fichier
```

**Exemples simples :**
```bash
awk '{print $1}' file           # 1√®re colonne
awk '{print $2}' file           # 2e colonne
awk '{print $NF}' file          # Derni√®re colonne
awk '{print $1, $3}' file       # Colonnes 1 et 3
awk -F: '{print $1}' file       # D√©limiteur :
awk 'NR==5' file                # Ligne 5
awk 'NR>=5 && NR<=10' file      # Lignes 5 √† 10
awk '/pattern/' file            # Lignes contenant "pattern"
awk '!/pattern/' file           # Lignes NE contenant PAS "pattern"
awk 'length > 80' file          # Lignes > 80 caract√®res
```

**Exemples avanc√©s :**
```bash
# Somme d'une colonne
awk '{sum += $1} END {print sum}' numbers.txt

# Moyenne
awk '{sum += $1; count++} END {print sum/count}' numbers.txt

# Afficher avec condition
awk '$3 > 100 {print $1, $3}' data.txt

# Compter lignes
awk 'END {print NR}' file

# Afficher colonnes avec formatage
awk '{printf "%-10s %5d\n", $1, $2}' file
```

**Variables sp√©ciales :**
```bash
$0      # Ligne enti√®re
$1, $2  # 1√®re, 2e colonne
NF      # Nombre de champs (colonnes)
NR      # Num√©ro de ligne
FS      # D√©limiteur d'entr√©e (Field Separator)
OFS     # D√©limiteur de sortie
```

---

#### `tr` - Translate

**Description :**  
Remplace ou supprime des caract√®res.

**Syntaxe :**
```bash
tr [options] SET1 SET2
```

**Exemples :**
```bash
# Minuscules ‚Üí Majuscules
echo "hello" | tr 'a-z' 'A-Z'           # HELLO

# Majuscules ‚Üí Minuscules
echo "HELLO" | tr 'A-Z' 'a-z'           # hello

# Supprimer caract√®res
echo "hello123" | tr -d '0-9'           # hello

# Supprimer espaces
echo "a b c" | tr -d ' '                # abc

# Remplacer espaces par underscores
echo "hello world" | tr ' ' '_'         # hello_world

# Supprimer doublons
echo "heeelllooo" | tr -s 'e'           # hello

# Supprimer retours chariot (Windows ‚Üí Unix)
tr -d '\r' < windows.txt > unix.txt
```

---

### üîß Variables et environnement

#### Variables shell

**D√©finir une variable :**
```bash
VAR="valeur"                # PAS d'espace autour du =
name="John"
count=42
```

**Utiliser une variable :**
```bash
echo $VAR                   # Afficher
echo "$VAR"                 # Recommand√© (g√®re espaces)
echo ${VAR}                 # Syntaxe explicite
```

**Variables sp√©ciales :**
```bash
$?      # Code retour derni√®re commande (0 = succ√®s)
$$      # PID du shell courant
$!      # PID dernier processus en arri√®re-plan
$0      # Nom du script
$1, $2  # Arguments du script
$#      # Nombre d'arguments
$@      # Tous les arguments (liste)
$*      # Tous les arguments (cha√Æne)
```

**Exemples :**
```bash
# V√©rifier le code retour
ls /inexistant
echo $?                     # Affiche un code != 0

# Utiliser dans une condition
if [ $? -eq 0 ] ; then
    echo "Succ√®s"
fi

# Sauvegarder le code retour
ls /tmp
retour=$?
if [ $retour -ne 0 ] ; then
    echo "Erreur: $retour"
fi
```

---

#### Variables d'environnement

**Variables importantes :**
```bash
$HOME       # R√©pertoire home (/home/username)
$USER       # Nom d'utilisateur
$PATH       # Chemins de recherche des commandes
$PWD        # R√©pertoire courant
$OLDPWD     # R√©pertoire pr√©c√©dent
$SHELL      # Shell par d√©faut
$LANG       # Langue syst√®me
$TERM       # Type de terminal
```

**Afficher :**
```bash
echo $HOME
echo $PATH
env                         # Toutes les variables d'environnement
printenv PATH               # Afficher PATH
```

**Modifier PATH :**
```bash
# Ajouter √† la fin
export PATH="$PATH:/nouveau/chemin"

# Ajouter au d√©but (prioritaire)
export PATH="/nouveau/chemin:$PATH"

# V√©rifier
echo $PATH | tr ':' '\n'    # Afficher chaque chemin sur une ligne
```

---

### üîÑ Processus et jobs

#### Gestion des processus

**Lancer en arri√®re-plan :**
```bash
command &                   # Lance en arri√®re-plan
sleep 100 &                 # Exemple
```

**Contr√¥le clavier :**
```bash
Ctrl-C                      # Interrompre (SIGINT)
Ctrl-Z                      # Suspendre (SIGTSTP)
Ctrl-D                      # EOF (fin de saisie)
```

**Gestion des jobs :**
```bash
jobs                        # Liste les jobs
jobs -l                     # Avec PIDs
fg                          # Ramener en avant-plan
fg %1                       # Ramener job 1
bg                          # Continuer en arri√®re-plan
bg %2                       # Continuer job 2
kill %1                     # Tuer job 1
disown                      # D√©tacher du terminal
```

**Exemples :**
```bash
# Lancer plusieurs commandes en arri√®re-plan
sleep 10 &
sleep 20 &
sleep 30 &
jobs                        # Voir les 3 jobs

# Reprendre un job
fg %2                       # Job 2 en avant-plan

# Suspendre puis continuer en arri√®re-plan
gedit file.txt              # Lance gedit
# Ctrl-Z                    # Suspendre
bg                          # Continuer en arri√®re-plan
```

---

#### `ps` - Process Status

**Description :**  
Liste les processus.

**Syntaxe :**
```bash
ps [options]
```

**Options courantes :**
```bash
ps                          # Processus du terminal courant
ps aux                      # Tous les processus (BSD style)
ps -ef                      # Tous les processus (Unix style)
ps -u username              # Processus d'un utilisateur
ps -p PID                   # Infos sur un PID sp√©cifique
```

**Colonnes importantes :**
```
USER    Utilisateur
PID     Process ID
%CPU    Utilisation CPU
%MEM    Utilisation m√©moire
VSZ     M√©moire virtuelle (Ko)
RSS     M√©moire r√©sidente (Ko)
TTY     Terminal
STAT    √âtat (R=running, S=sleeping, Z=zombie, T=stopped)
START   Heure de d√©marrage
TIME    Temps CPU
COMMAND Commande
```

**Exemples :**
```bash
# Trouver un processus
ps aux | grep firefox

# Processus tri√©s par CPU
ps aux --sort=-%cpu | head

# Processus tri√©s par m√©moire
ps aux --sort=-%mem | head

# Arbre des processus
ps auxf                     # Avec hi√©rarchie
pstree                      # Arbre visuel
```

---

#### `kill` - Envoyer un signal

**Description :**  
Envoie un signal √† un processus.

**Syntaxe :**
```bash
kill [signal] PID
```

**Signaux courants :**
```bash
kill PID                    # SIGTERM (15) - terminaison propre
kill -9 PID                 # SIGKILL - forc√© (non capturable)
kill -15 PID                # SIGTERM explicite
kill -2 PID                 # SIGINT (Ctrl-C)
kill -1 PID                 # SIGHUP (recharger config)
kill -STOP PID              # SIGSTOP - pause
kill -CONT PID              # SIGCONT - reprendre
```

**Exemples :**
```bash
# Tuer proprement
kill 1234

# Forcer si √ßa ne r√©pond pas
kill -9 1234

# Tuer tous les processus d'un nom
killall firefox
pkill firefox

# Tuer par motif
pkill -f "python.*server"
```

---

## üìú TP2 - SCRIPTS SHELL

### üîÅ Structures de contr√¥le

#### Boucle `while`

**Syntaxe :**
```bash
while [ condition ] ; do
    commandes
done
```

**Exemples :**
```bash
# Boucle simple
i=1
while [ $i -le 10 ] ; do
    echo "It√©ration $i"
    i=$((i + 1))
done

# Boucle infinie
while true ; do
    echo "Infini"
    sleep 1
done

# Lire un fichier ligne par ligne
while read line ; do
    echo "Ligne: $line"
done < fichier.txt

# Lire entr√©e utilisateur
while read -p "Nom: " name ; do
    echo "Bonjour $name"
done
```

---

#### Boucle `for`

**Syntaxe :**
```bash
for var in liste ; do
    commandes
done
```

**Exemples :**
```bash
# Liste explicite
for fruit in pomme banane orange ; do
    echo "$fruit"
done

# Range num√©rique (bash)
for i in {1..10} ; do
    echo "$i"
done

# Avec seq (portable)
for i in $(seq 1 10) ; do
    echo "$i"
done

# Fichiers d'un r√©pertoire
for file in *.txt ; do
    echo "Fichier: $file"
done

# Arguments du script
for arg in "$@" ; do
    echo "Argument: $arg"
done

# Style C (bash)
for ((i=1; i<=10; i++)) ; do
    echo "$i"
done
```

---

#### Boucle `until`

**Syntaxe :**
```bash
until [ condition ] ; do
    commandes
done
```

**Exemples :**
```bash
# Boucle jusqu'√† ce que condition soit vraie
i=1
until [ $i -gt 10 ] ; do
    echo "$i"
    i=$((i + 1))
done

# Attendre qu'un fichier existe
until [ -f /tmp/flag ] ; do
    echo "En attente..."
    sleep 1
done
```

---

#### Condition `if`

**Syntaxe :**
```bash
if [ condition ] ; then
    commandes
elif [ autre_condition ] ; then
    autres_commandes
else
    commandes_par_defaut
fi
```

**Tests de fichiers :**
```bash
[ -f file ]     # Fichier r√©gulier existe
[ -d dir ]      # R√©pertoire existe
[ -e path ]     # Chemin existe (fichier ou dossier)
[ -r file ]     # Fichier lisible
[ -w file ]     # Fichier modifiable
[ -x file ]     # Fichier ex√©cutable
[ -s file ]     # Fichier non vide
[ -L link ]     # Lien symbolique
[ file1 -nt file2 ]  # file1 plus r√©cent que file2
[ file1 -ot file2 ]  # file1 plus ancien que file2
```

**Tests de cha√Ænes :**
```bash
[ -z "$str" ]           # Cha√Æne vide
[ -n "$str" ]           # Cha√Æne non vide
[ "$a" = "$b" ]         # √âgalit√©
[ "$a" != "$b" ]        # Diff√©rence
[ "$a" < "$b" ]         # Ordre alphab√©tique (attention: √©chapper <)
[[ "$a" < "$b" ]]       # Mieux: double crochet (bash)
```

**Tests num√©riques :**
```bash
[ $a -eq $b ]           # √âgal
[ $a -ne $b ]           # Diff√©rent
[ $a -lt $b ]           # Plus petit (<)
[ $a -le $b ]           # Plus petit ou √©gal (‚â§)
[ $a -gt $b ]           # Plus grand (>)
[ $a -ge $b ]           # Plus grand ou √©gal (‚â•)
```

**Op√©rateurs logiques :**
```bash
[ cond1 -a cond2 ]      # ET (AND)
[ cond1 -o cond2 ]      # OU (OR)
[ ! cond ]              # NON (NOT)

# Mieux (bash) :
[[ cond1 && cond2 ]]    # ET
[[ cond1 || cond2 ]]    # OU
[[ ! cond ]]            # NON
```

**Exemples :**
```bash
# Test simple
if [ -f "file.txt" ] ; then
    echo "Le fichier existe"
fi

# Avec else
if [ $# -eq 0 ] ; then
    echo "Aucun argument"
else
    echo "Arguments: $@"
fi

# Avec elif
if [ $score -ge 90 ] ; then
    echo "A"
elif [ $score -ge 80 ] ; then
    echo "B"
elif [ $score -ge 70 ] ; then
    echo "C"
else
    echo "F"
fi

# Tests multiples
if [ -f "file.txt" ] && [ -r "file.txt" ] ; then
    echo "Fichier lisible"
fi

# Test de cha√Æne
if [ -z "$name" ] ; then
    echo "Nom vide"
fi
```

---

#### `case` - Switch

**Syntaxe :**
```bash
case $variable in
    pattern1)
        commandes
        ;;
    pattern2)
        commandes
        ;;
    *)
        defaut
        ;;
esac
```

**Exemples :**
```bash
# Case simple
case $fruit in
    pomme)
        echo "C'est une pomme"
        ;;
    banane|orange)
        echo "C'est une banane ou orange"
        ;;
    *)
        echo "Fruit inconnu"
        ;;
esac

# Avec patterns
case $file in
    *.txt)
        echo "Fichier texte"
        ;;
    *.jpg|*.png)
        echo "Image"
        ;;
    *.sh)
        echo "Script shell"
        ;;
    *)
        echo "Type inconnu"
        ;;
esac

# Menu
echo "1) Option A"
echo "2) Option B"
read -p "Choix: " choice

case $choice in
    1)
        echo "Vous avez choisi A"
        ;;
    2)
        echo "Vous avez choisi B"
        ;;
    *)
        echo "Choix invalide"
        ;;
esac
```

---

### üéØ Fonctions

**Syntaxe :**
```bash
nom_fonction() {
    commandes
    return code
}

# Ou :
function nom_fonction {
    commandes
}
```

**Exemples :**
```bash
# Fonction simple
hello() {
    echo "Hello World"
}
hello  # Appel

# Avec param√®tres
greet() {
    echo "Hello $1"
}
greet "Alice"           # Affiche: Hello Alice

# Avec return
add() {
    local result=$(($1 + $2))
    echo $result        # Retourner via echo
}
sum=$(add 5 3)          # sum=8

# Avec code retour
check_file() {
    if [ -f "$1" ] ; then
        return 0        # Succ√®s
    else
        return 1        # √âchec
    fi
}

if check_file "test.txt" ; then
    echo "Le fichier existe"
fi

# Variables locales
fonction() {
    local var="valeur locale"
    echo "$var"
}
```

---

### üìã Arguments

**Variables d'arguments :**
```bash
$0      # Nom du script
$1      # 1er argument
$2      # 2e argument
$#      # Nombre d'arguments
$@      # Tous les arguments (liste)
$*      # Tous les arguments (cha√Æne)
```

**Exemples :**
```bash
#!/bin/bash
echo "Script: $0"
echo "Nombre d'arguments: $#"
echo "Arguments: $@"

if [ $# -eq 0 ] ; then
    echo "Usage: $0 <arg1> <arg2> ..."
    exit 1
fi

echo "Premier argument: $1"
```

---

#### `shift` - D√©caler les arguments

**Description :**  
D√©cale les arguments vers la gauche. `$2` devient `$1`, etc.

**Exemples :**
```bash
# Traiter tous les arguments
while [ $# -gt 0 ] ; do
    echo "Argument: $1"
    shift
done

# D√©caler de N positions
shift 2         # Ignore les 2 premiers arguments
```

---

#### `set` - Red√©finir les arguments

**Description :**  
Red√©finit les arguments positionnels.

**Exemples :**
```bash
# D√©finir de nouveaux arguments
set -- "arg1" "arg2" "arg3"
echo $1         # arg1
echo $#         # 3

# Parser une cha√Æne
ligne="champ1:champ2:champ3"
IFS=: set -- $ligne
echo $1         # champ1
echo $2         # champ2

# Splitter une sortie
set -- $(ls)
echo "Premier fichier: $1"
```

---

### üîß Options de script

**Options importantes :**
```bash
set -e              # Arr√™ter sur erreur
set -u              # Erreur si variable non d√©finie
set -x              # Debug (affiche commandes)
set -o pipefail     # Erreur si pipe √©choue
```

**Exemple de script robuste :**
```bash
#!/bin/bash
set -euo pipefail   # Mode strict

# Votre code ici
```

---

### üì• Lecture d'entr√©e

#### `read` - Lire l'entr√©e

**Syntaxe :**
```bash
read [options] variable
```

**Options :**
```bash
read name                   # Lire une ligne
read -p "Nom: " name        # Avec prompt
read -s password            # Silencieux (pas d'√©cho)
read -n 1 key               # Lire 1 caract√®re
read -t 5 input             # Timeout de 5 secondes
read -a array               # Lire dans un tableau
read var1 var2 var3         # Lire plusieurs variables
```

**Exemples :**
```bash
# Simple
read -p "Entrez votre nom: " name
echo "Bonjour $name"

# Mot de passe
read -sp "Mot de passe: " password
echo ""
echo "Mot de passe enregistr√©"

# Avec timeout
if read -t 5 -p "R√©pondre en 5s: " answer ; then
    echo "Vous avez dit: $answer"
else
    echo "Timeout!"
fi

# Lire fichier ligne par ligne
while IFS= read -r line ; do
    echo "Ligne: $line"
done < fichier.txt
```

---

### üßÆ Arithm√©tique

**Syntaxes :**
```bash
# Double parenth√®ses (recommand√©)
result=$((5 + 3))           # 8
result=$((10 - 2))          # 8
result=$((4 * 2))           # 8
result=$((16 / 2))          # 8
result=$((17 % 9))          # 8 (modulo)

# Incr√©ment/d√©cr√©ment
i=$((i + 1))
i=$((i - 1))
((i++))
((i--))

# Avec let (ancien)
let result=5+3
let i++

# Avec expr (portable mais ancien)
result=$(expr 5 + 3)
```

**Exemples :**
```bash
# Calculs
a=10
b=5
sum=$((a + b))
diff=$((a - b))
prod=$((a * b))
quot=$((a / b))
mod=$((a % b))

# Boucle avec compteur
for ((i=1; i<=10; i++)) ; do
    echo "$i"
done

# Conditions num√©riques
if [ $count -gt 10 ] ; then
    echo "Plus de 10"
fi
```

---

### üé® Astuces avanc√©es

#### Expansion de param√®tres

**Substitutions :**
```bash
${var}              # Valeur de var
${var:-default}     # default si var vide/non d√©fini
${var:=default}     # D√©finir var=default si vide
${var:+valeur}      # valeur si var d√©fini
${var:?message}     # Erreur avec message si var vide

# Longueur
${#var}             # Longueur de la cha√Æne

# Substring
${var:start:length} # Extraire sous-cha√Æne
${var:5}            # Depuis position 5
${var:5:3}          # 3 caract√®res depuis position 5

# Remplacement
${var/pattern/replacement}      # Remplacer 1√®re occurrence
${var//pattern/replacement}     # Remplacer toutes
${var/#pattern/replacement}     # Si commence par pattern
${var/%pattern/replacement}     # Si finit par pattern

# Supprimer
${var#pattern}      # Supprimer prefix court
${var##pattern}     # Supprimer prefix long
${var%pattern}      # Supprimer suffix court
${var%%pattern}     # Supprimer suffix long
```

**Exemples :**
```bash
# Valeur par d√©faut
name=${1:-"Anonymous"}

# Obtenir extension
file="document.txt"
ext=${file##*.}         # txt

# Obtenir nom sans extension
base=${file%.*}         # document

# Chemin ‚Üí nom de fichier
path="/home/user/file.txt"
filename=${path##*/}    # file.txt

# Remplacer
text="hello world"
result=${text/world/universe}   # hello universe
```

---

#### Tableaux (bash)

**D√©finir :**
```bash
array=(val1 val2 val3)
array[0]="premier"
```

**Utiliser :**
```bash
${array[0]}         # Premier √©l√©ment
${array[@]}         # Tous les √©l√©ments
${#array[@]}        # Nombre d'√©l√©ments
${!array[@]}        # Indices
```

**Exemples :**
```bash
fruits=(pomme banane orange)
echo ${fruits[0]}           # pomme
echo ${fruits[@]}           # pomme banane orange
echo ${#fruits[@]}          # 3

# Boucle
for fruit in "${fruits[@]}" ; do
    echo "$fruit"
done

# Ajouter
fruits+=("raisin")
```

---

#### Substitution de commandes

**Syntaxes :**
```bash
result=$(commande)      # Moderne (recommand√©)
result=`commande`       # Ancien (backticks)
```

**Exemples :**
```bash
# Capturer sortie
files=$(ls)
date=$(date +%Y-%m-%d)
count=$(wc -l < file.txt)

# Utiliser dans cha√Æne
echo "Il y a $(ls | wc -l) fichiers"

# Nested (imbriqu√©)
result=$(echo "Nombre: $(wc -l < file)")
```

---

#### Redirection avanc√©e

**Here document :**
```bash
cat << EOF
Texte multiligne
Ligne 2
Ligne 3
EOF

# Dans une variable
content=$(cat << EOF
Ligne 1
Ligne 2
EOF
)

# Avec expansion d√©sactiv√©e
cat << 'EOF'
$VAR ne sera pas expans√©
EOF
```

**Here string :**
```bash
grep "pattern" <<< "texte √† chercher"
wc -w <<< "hello world"
```

---

## üéì R√©capitulatif Commandes Essentielles

### Navigation et fichiers
```
cd, pwd, ls, mkdir, touch, cp, mv, rm, cat, echo
```

### Recherche
```
grep, find, wc, head, tail
```

### Traitement texte
```
cut, sort, uniq, sed, awk, tr
```

### Redirections
```
>, >>, <, 2>, &>, |, |&
```

### Processus
```
&, Ctrl-C, Ctrl-Z, jobs, fg, bg, ps, kill
```

### Variables
```
VAR=value, $VAR, $0-$9, $#, $@, $?, $$
```

### Structures (TP2)
```
while, for, until, if, case, function
```

### Outils avanc√©s
```
shift, set, read, $((...)), $((cmd))
```

---

**Auteur :** Guide ISE TP1/TP2 - ENSIIE 2025